# ARM Cortex-R Series (Armv7-R) Programmer’s Guide
## Introduction to Assembly Language
### The ARM instruction sets 指令集
 The ARMv7 architecture is a 32-bit processor architecture. It is a load/store architecture, meaning that data-processing instructions operate on values in general purpose registers. Only load and store instructions access memory. General purpose registers are also 32 bits. Throughout this book
 
 when we refer to a word, we mean 32 bits. 
 A doubleword is therefore 64 bits and a halfword is 16 bits wide.
 
 Though the ARMv7 architecture is a 32-bit architecture, individual（单个） processor implementations（实现） do not necessarily have 32-bit width for all blocks and interconnections（互联的）. For example, it is possible to have 64-bit, or wider paths for instruction fetches （指令获取） or data accesses.
 
 
 Most ARM processors support a number of （许多） different instruction sets, while some (for example, the Cortex-M3 processor) do not in fact execute （执行）the original ARM instruction set. There are at least two instruction sets that ARM processors can use.
 
 - ARM (32-bit instructions)：This is the original ARM instruction set.
 - Thumb（拇指）The Thumb instruction set was first added in the ARM7TDMI processor and contained（包含） only 16-bit instructions, that gave much smaller programs (memory footprint can be a major concern in smaller embedded systems) *at the cost of* （以...为代价）some performance. 
 Recent processors, including those in the Cortex-R series, support Thumb-2 technology, 
 that extends(扩展） the Thumb instruction set to provide a mix of 16-bit and 32-bit instructions. This gives the best of both worlds, performance similar to that of ARM, with code size similar to that of Thumb. Because of its size and performance advantages（优势）, it is increasingly（日益） common for all code to be compiled or assembled to *take advantage of*（利用） Thumb-2 technology.
 
 Older ARM processors often contained code that was compiled for ARM state and code that was compiled for Thumb state. ARM code, with 32-bit instructions, was more powerful and required fewer instructions to perform a particular task and so might be preferred for performance critical parts of the system. It was also used for exception handler code, because exceptions （异常）could not be handled in Thumb state on ARM7 or ARM9 Series processors.
 
 Thumb code, using 16-bit instructions, requires more instructions *to carry out*（执行） the same task, when compared with ARM code. Thumb code can typically encode smaller constant values within instructions and has shorter relative branches. See Branches. The available range for relative branches is approximately ±32MB for ARM instructions and ±16MB for the Thumb-2 extension. Thumb is also limited where only 16-bit instructions are used, with conditional branches having a range of ±256 Bytes and unconditional relative branches being limited to ±2048 bytes .
 
 However, because Thumb instructions are only half of the size, programs are typically a third smaller than their ARM code equivalent（同等物）. Thumb instructions are therefore（所以） used when code density（代码密度） is important, and to reduce（减少） system memory requirements（要求）. Thumb code can also outperform（表现优于） ARM when the processor is directly connected to a **narrow** (16-bit) memory, without the benefit of cache. One Thumb instruction can be fetched on each cycle, whereas each 32-bit ARM instruction requires two clock cycles per fetch.
 
 When executing a Thumb instruction, the PC reads as the address of the current instruction plus 4. The only 16-bit Thumb instructions that can directly modify the PC are certain（确定的） encodings of MOV and ADD. The value written to the PC is forced to be *halfword-aligned*（半字对齐） by ignoring its least significant bit, *treating* that bit *as* （将...当作） being 0.
 
 In ARMCC, the option --thumb or -arm (the default) enables selection of the instruction set used for compilation. A program can branch between these two instruction sets at run-time.
 
 The currently used instruction set is indicated（指示） by the CPSR T bit and the core is said to be in ARM state (T = 0) or Thumb state (T = 1). Code has to be explicitly （显式）compiled or assembled to one state or the other. An explicit instruction is used to change between instruction sets. Calling functions that are compiled for a different state is known as interworking. We’ll take a more detailed look at this in Interworking.
 
 For Thumb assembly code, there is often a choice of 16-bit and 32-bit instruction encodings, with the 16-bit versions being generated by default. The .W (32-bit) and .N (16-bit) width specifiers can be used to force a particular encoding（特定编码） (if such an encoding exists), for example:
 
```asm
     BCS.W   label   ; forces 32-bit instruction even for a short branch
     B.N     label   ; faults if label out of range for 16-bit (narrow)instruction
     
```

 Thumb-2 :Despite continued rumours to the contrary, there is *no such thing as a Thumb-2 instruction set*. Thumb-2 technology was introduced in ARMv6T2, and is required in ARMv7. This technology extends the original 16-bit Thumb instruction set to include 32-bit instructions. The range of 32-bit Thumb instructions included in ARMv6T2 permits Thumb code to achieve performance similar to ARM code, with code density better than that of the purely 16-bit Thumb code.

  